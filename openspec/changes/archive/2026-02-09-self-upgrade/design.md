## Context

**背景**：
当前系统是一个主备高可用的 web 服务架构，包含以下组件：
- Web 服务：Java + Python 双语言支持，通过 systemd 管理
- 数据库：本地部署的 GaussDB 主备集群，通过 gaussdb-kernel 同步
- 高可用：Keepalived 提供 VIP 切换和主备仲裁
- 配置同步：rsync 定时同步配置文件（5分钟间隔，单向主→备）

**现状问题**：
- 缺乏自动化升级能力，需要手动在两个节点上分别操作
- 升级过程中需要人工干预控制 VIP 切换、数据库升级顺序等
- 缺乏统一的健康检查机制，升级成功/失败判断依赖人工验证
- 没有标准化的备份和回滚流程，回滚操作风险较高
- 停机时间要求严格（4分钟以内），手动操作难以满足

**约束条件**：
- 部署方式：传统进程部署（非容器化）
- 升级方式：用户手动上传升级包到指定路径，通过接口解压分发
- 停机要求：不能停机升级，总停机时间 < 4分钟
- 升级顺序：滚动升级（先备后主），中间切换 VIP
- GaussDB 与服务升级不解耦，需要同步升级
- 配置文件在升级过程中需要暂停 rsync 同步
- 根密钥必须备份（升级时会生成新的随机根密钥覆盖旧版本）

**相关方**：
- 系统管理员：触发升级、监控进度、处理异常
- 最终用户：期望无感知升级，服务持续可用
- 运维团队：负责备份、回滚、故障排查

---

## Goals / Non-Goals

**Goals:**

1. **自动化滚动升级流程**
   - 在主备节点间自动协调升级顺序（先备后主）
   - 自动控制 VIP 切换时机，确保服务连续性
   - 升级总时间控制在 4分钟以内（单节点升级基线 2分钟 + VIP 切换 30秒 + 健康检查缓冲）

2. **统一的健康检查机制**
   - 提供标准化的 `/health` 接口
   - 检查项：数据库连接、服务端口、Keepalived 心跳
   - 自动判断升级成功/失败，无需人工验证

3. **完善的备份和回滚能力**
   - 升级前自动备份：代码包（jar）、配置文件（根密钥）、数据库（全量）
   - 保留最近 1 次升级的备份，按时间戳命名
   - 手动触发回滚，失败仅报错不自动回滚

4. **Keepalived 集成**
   - 支持 Keepalived VIP 的自动切换控制
   - 使用 priority 调整或 dummy 接口技术实现手动触发切换
   - 升级失败时保持接口可用，以供回退接口调用

5. **配置同步协调**
   - 升级触发后立即暂停 rsync 同步
   - 两个节点升级完成后恢复 rsync
   - 避免新版本配置被旧版本覆盖

**Non-Goals:**

1. **不涉及**：
   - 自动检测远端新版本（版本检查不包含在本设计中）
   - 自动下载升级包（依赖用户手动上传）
   - 容器化部署支持（仅支持传统进程部署）
   - 灰度发布（固定主备滚动升级）
   - 自动回滚（失败仅报错，手动回滚）
   - 数据库独立升级（GaussDB 与服务同步升级）
   - Python 脚本独立升级（Java 和 Python 一起升级）

2. **暂不考虑**：
   - 操作系统版本、Java/Python/GaussDB/Keepalived 具体版本
   - 备份文件的具体存储位置（抽象考虑）
   - Web 服务具体安装目录结构
   - Java 和 Python 服务的详细架构关系

---

## Decisions

### 决策 1: 升级流程采用滚动升级（先备后主）

**选择**：滚动升级策略

**理由**：
- 满足不停机升级要求，备节点升级期间主节点继续提供服务
- 先升级备节点并验证成功后再升级主节点，风险可控
- 符合高可用架构的最佳实践

**替代方案**：
- 停机升级：先停止主节点，升级后切换 VIP
  - 拒绝理由：不符合不停机要求，停机时间难以控制在 4分钟以内

---

### 决策 2: VIP 切换控制方式

**选择**：使用 Keepalived priority 动态调整实现手动切换

**理由**：
- Keepalived 本身没有原生的手动切换命令
- 通过调整 priority 可以优雅地触发 VIP 切换
- 不需要停止 keepalived 服务，避免影响高可用状态
- 符合用户需求（不清楚是否可以手动控制，基于技术调研选择可行方案）

**技术实现**：
```
# 提升备节点优先级 > 主节点，触发 VIP 切换
# 通过 vrrp_script 或直接修改配置文件并重载实现
```

**替代方案**：
- Dummy 接口技术：配置虚拟 dummy 接口并通过控制其状态触发 failover
  - 拒绝理由：需要额外的内核模块配置，复杂度高，不如 priority 方案简洁
- 停止 keepalived 服务：在备节点停止 keepalived
  - 拒绝理由：生产环境不推荐，可能影响高可用状态的稳定性

---

### 决策 3: 健康检查接口设计

**选择**：
- 接口路径：`/health`
- 检查项：数据库连接、服务端口、Keepalived 心跳
- 成功标准：服务启动成功 + 所有健康检查项通过
- 失败标准：服务启动失败、健康检查超时、数据库连接失败、业务接口返回错误

**理由**：
- `/health` 是业界标准的健康检查接口路径
- 覆盖了服务可用性的核心维度（数据库、服务端口、网络）
- 明确的成功/失败判断标准，便于自动化流程

**替代方案**：
- `/api/health` 或其他路径
  - 拒绝理由：`/health` 更简洁且符合 RESTful 规范
- 增加检查项（配置完整性、资源使用率、日志检查等）
  - 拒绝理由：用户问卷中未勾选，当前阶段保持简洁，后续可扩展

---

### 决策 4: 备份范围和策略

**选择**：
- 备份内容：代码包（jar）、配置文件（根密钥）、数据库（全量）
- 保留周期：最近 1 次升级的备份
- 命名规则：按时间戳（例如：`backup_20250107_143025`）

**理由**：
- 根密钥必须备份：升级时会生成新根密钥覆盖旧版本，需要从备份恢复
- 代码包和数据库是回滚的核心依赖
- 保留 1 次备份足够支持最近一次回滚，避免存储浪费
- 时间戳命名直观且便于追溯

**替代方案**：
- 备份 Python 脚本代码
  - 拒绝理由：用户问卷中未勾选，且 Java 和 Python 一起升级
- 按版本号命名（`backup_v1.0.0_to_v1.1.0`）
  - 拒绝理由：用户选择了时间戳命名，且升级包版本格式不明确

---

### 决策 5: 超时配置

**选择**：
- 单个节点升级超时：15分钟
- VIP 切换超时：30秒
- 健康检查超时：30秒
- 升级失败后不自动回滚，仅报错

**理由**：
- 单个节点升级超时 15分钟：用户指定，考虑了服务启动基线（2分钟）和额外缓冲时间
- VIP 切换超时 30秒：用户指定，符合 VRRP 协议的典型切换时间
- 健康检查超时 30秒：用户指定，平衡了响应速度和误判率
- 不自动回滚：用户明确要求失败仅报错，由用户手动触发回滚

**替代方案**：
- 单个节点升级超时 2.5-3分钟（建议值）
  - 拒绝理由：用户明确指定 15分钟，需遵循用户需求
- 升级失败自动回滚
  - 拒绝理由：用户明确要求手动回滚

---

### 决策 6: 配置同步协调

**选择**：
- 升级触发后立即中断 rsync 同步
- 两个节点升级完成后恢复 rsync

**理由**：
- 避免新版本配置被 rsync 从旧版本节点同步覆盖
- 符合用户需求："计划在触发升级节点后立刻中断文件同步，待两个节点都升级完毕后再恢复"
- 简单可靠，通过控制 rsync 服务启停即可实现

**替代方案**：
- 升级期间继续 rsync，升级完成后再统一同步配置
  - 拒绝理由：存在配置冲突风险，不符合用户需求

---

### 决策 7: GaussDB 升级策略

**选择**：
- GaussDB 与 web 服务同步升级
- 先升级备节点 GaussDB，触发 VIP 切换后，原备节点（现主节点）升级完成，再升级原主节点（现已备节点）GaussDB
- 表字段变化要求向后兼容，高版本 SQL 不能影响低版本正常运行

**理由**：
- 满足用户需求："GaussDB 与服务升级不解耦"
- 滚动升级顺序确保数据库连续可用
- 向后兼容约束保证升级过程中的数据完整性

**替代方案**：
- GaussDB 独立升级，与 web 服务解耦
  - 拒绝理由：用户明确要求不解耦

---

### 决策 8: 升级触发方式

**选择**：
- 用户手动上传升级包到指定路径
- 调用分发升级包的接口进行解压和分发

**理由**：
- 符合当前发布流程（用户手动上传）
- 接口化设计便于自动化集成
- 不涉及远端版本检查和自动下载（非目标）

---

## Risks / Trade-offs

### 风险 1: VIP 切换失败或超时
- **描述**：Keepalived priority 调整可能因网络抖动、配置错误等原因导致切换失败或超时
- **影响**：升级流程中断，服务可能不可用
- **缓解措施**：
  - 配置合理的 VIP 切换超时时间（30秒）
  - 升级前检查 Keepalived 状态，确保高可用集群正常
  - 提供 VIP 切换失败后的回滚接口，手动恢复原主节点状态
  - 记录详细日志，便于排查问题

---

### 风险 2: 升级超时导致流程阻塞
- **描述**：单个节点升级超时（15分钟）可能因服务启动慢、健康检查失败等原因触发
- **影响**：升级流程中断，用户需要手动介入处理
- **缓解措施**：
  - 升级前预检查磁盘空间、依赖项等资源
  - 提供升级进度实时反馈，让用户了解当前状态
  - 超时后报错并提供详细的错误日志
  - 支持从超时状态恢复，重新触发升级

---

### 风险 3: 健康检查误判导致升级失败
- **描述**：健康检查可能因瞬时网络波动、数据库连接池预热等原因误判为失败
- **影响**：升级失败，触发报错和可能的回滚操作
- **缓解措施**：
  - 健康检查超时设置为 30秒，避免瞬时抖动影响
  - 健康检查失败后提供详细错误信息（数据库连接状态、端口监听状态等）
  - 支持重试机制（可选）
  - 提供手动确认升级成功的接口，绕过健康检查（谨慎使用）

---

### 风险 4: rsync 同步暂停期间配置不一致
- **描述**：rsync 暂停期间，两个节点的配置可能因其他操作产生不一致
- **影响**：升级恢复 rsync 后可能产生配置覆盖冲突
- **缓解措施**：
  - rsync 暂停期间禁止手动修改配置文件
  - 升级完成后强制同步配置，确保一致性
  - 记录 rsync 暂停/恢复时间和配置变更日志
  - 提供配置一致性检查接口

---

### 风险 5: 数据库升级失败导致数据不一致
- **描述**：GaussDB 升级可能因 schema 不兼容、数据迁移失败等原因失败
- **影响**：两个节点的数据库状态不一致，可能影响服务可用性
- **缓解措施**：
  - schema 变更强制要求向后兼容，高版本 SQL 不影响低版本
  - 升级前全量备份数据库
  - 先升级备节点并验证，失败则终止流程，不影响主节点
  - 提供 schema 兼容性检查工具

---

### 风险 6: 根密钥备份或恢复失败
- **描述**：根密钥备份可能因磁盘空间不足、权限问题等失败，恢复时也可能出错
- **影响**：升级后服务无法使用新密钥或旧密钥，导致服务不可用
- **缓解措施**：
  - 升级前检查备份目录的磁盘空间和写权限
  - 根密钥备份文件加密存储
  - 提供根密钥恢复验证接口，确保恢复成功
  - 升级失败回滚时自动恢复旧根密钥

---

### 风险 7: 回滚操作失败
- **描述**：手动回滚可能因备份文件损坏、回滚脚本错误等原因失败
- **影响**：无法恢复到旧版本，服务持续不可用
- **缓解措施**：
  - 升级前验证备份文件完整性（校验和）
  - 回滚前提供回滚预检查，验证备份文件和依赖项
  - 回滚操作记录详细日志
  - 提供回滚失败后的应急方案（重新升级、从远程获取旧版本包等）

---

### 权衡 1: 升级超时时间较长 vs 停机时间要求
- **权衡**：单个节点升级超时 15分钟较长，但用户总停机时间要求 < 4分钟
- **分析**：升级超时是异常情况的处理时间，正常升级应该在 2分钟（服务启动）+ 30秒（VIP 切换）+ 30秒（健康检查）= 3分钟内完成
- **结论**：合理，超时时间主要覆盖异常情况，不影响正常升级流程的停机时间

---

### 权衡 2: 手动回滚 vs 自动回滚
- **权衡**：手动回滚需要用户介入，但自动回滚可能误判导致频繁回滚
- **分析**：用户明确要求手动回滚，避免自动回滚的误判风险
- **结论**：合理，符合用户需求，但需要提供清晰的回滚指引和错误信息

---

## Migration Plan

### 部署步骤

#### 阶段 1: 准备阶段（升级前）
1. **备份**
   - 备份代码包（jar）
   - 备份配置文件，特别关注根密钥
   - 全量备份数据库
   - 验证备份文件完整性（校验和）
   - 记录备份时间戳和文件路径

2. **预检查**
   - 检查磁盘空间（升级包、备份文件、日志）
   - 检查网络连通性（两个节点间通信、Keepalived 心跳）
   - 检查 Keepalived 状态（主备角色、VIP 当前归属）
   - 检查数据库状态（主备同步、连接可用性）
   - 检查 rsync 服务状态
   - 检查 Java/Python 服务运行状态

3. **上传升级包**
   - 用户手动上传升级包到指定路径
   - 校验升级包签名
   - 解压升级包到临时目录

---

#### 阶段 2: 升级备节点
1. **暂停配置同步**
   - 中断 rsync 同步服务
   - 记录 rsync 暂停时间

2. **升级备节点 GaussDB**
   - 执行数据库 schema 变更（向后兼容）
   - 验证数据库升级成功
   - 等待主备数据库同步完成

3. **停止备节点服务**
   - 通过 systemd 停止 Java 和 Python 服务
   - 验证服务进程已停止

4. **替换代码包**
   - 备份旧版本 jar 包
   - 安装新版本 jar 包
   - 验证文件完整性

5. **启动备节点服务**
   - 通过 systemd 启动 Java 和 Python 服务
   - 记录服务启动时间

6. **健康检查**
   - 调用 `/health` 接口检查备节点
   - 检查数据库连接
   - 检查服务端口监听
   - 检查 Keepalived 心跳
   - 健康检查超时：30秒

7. **备节点升级完成**
   - 记录备节点升级完成时间
   - 持续监控备节点健康状态（30秒内 3 次检查）

---

#### 阶段 3: VIP 切换
1. **准备切换**
   - 确认备节点升级成功且健康检查通过
   - 确认当前 VIP 在主节点

2. **触发 VIP 切换**
   - 调整备节点 Keepalived priority > 主节点
   - 等待 Keepalived 检测并触发切换
   - VIP 切换超时：30秒

3. **验证切换成功**
   - 确认 VIP 现在在原备节点（现主节点）
   - 验证流量正常路由到新主节点
   - 调用新主节点的 `/health` 接口

4. **记录切换信息**
   - 记录 VIP 切换时间
   - 记录当前主备节点角色

---

#### 阶段 4: 升级原主节点（现已备节点）
1. **升级原主节点 GaussDB**
   - 执行数据库 schema 变更（向后兼容）
   - 验证数据库升级成功
   - 等待主备数据库同步完成

2. **停止原主节点服务**
   - 通过 systemd 停止 Java 和 Python 服务
   - 验证服务进程已停止

3. **替换代码包**
   - 备份旧版本 jar 包
   - 安装新版本 jar 包
   - 验证文件完整性

4. **启动原主节点服务**
   - 通过 systemd 启动 Java 和 Python 服务
   - 记录服务启动时间

5. **健康检查**
   - 调用 `/health` 接口检查该节点
   - 检查数据库连接
   - 检查服务端口监听
   - 检查 Keepalived 心跳
   - 健康检查超时：30秒

6. **节点升级完成**
   - 记录该节点升级完成时间
   - 持续监控健康状态（30秒内 3 次检查）

---

#### 阶段 5: 升级后处理
1. **恢复配置同步**
   - 恢复 rsync 同步服务
   - 记录 rsync 恢复时间
   - 验证配置一致性

2. **最终验证**
   - 调用主节点的 `/health` 接口
   - 调用备节点的 `/health` 接口
   - 验证主备数据库同步状态
   - 验证 VIP 当前归属
   - 确认服务总停机时间 < 4分钟

3. **清理临时文件**
   - 删除升级包临时文件
   - 清理日志文件（保留关键日志）

4. **升级成功**
   - 记录升级完成时间
   - 发送升级成功通知（如果配置了通知机制）
   - 记录升级审计日志

---

### 回滚策略

#### 触发条件
- 用户手动触发回滚
- 升级失败后（仅报错，不自动回滚）

#### 回滚步骤
1. **回滚前检查**
   - 验证备份文件存在且完整
   - 检查备份时间戳
   - 确认当前升级失败状态

2. **停止当前服务**
   - 停止两个节点的 Java 和 Python 服务

3. **恢复代码包**
   - 从备份中恢复旧版本 jar 包
   - 验证文件完整性

4. **恢复配置文件**
   - 从备份中恢复配置文件，特别是根密钥
   - 验证配置文件正确性

5. **恢复数据库**
   - 从全量备份中恢复数据库
   - 验证数据库恢复成功

6. **恢复 rsync**
   - 确认 rsync 同步服务运行
   - 验证配置一致性

7. **启动服务**
   - 启动两个节点的 Java 和 Python 服务
   - 健康检查验证

8. **恢复 VIP**
   - 恢复原始主备节点角色（通过 Keepalived priority 调整）

9. **回滚完成**
   - 记录回滚时间
   - 发送回滚完成通知
   - 记录回滚审计日志

---

### 升级失败处理

#### 备节点升级失败
1. 报错并记录详细日志
2. 提供 VIP 不切换选项（保持主节点服务）
3. 手动回滚备节点
4. 主节点继续提供服务

#### VIP 切换失败
1. 报错并记录详细日志
2. 尝试重新触发 VIP 切换（重试 1-2 次）
3. 如果仍失败，手动介入检查 Keepalived 配置
4. 保持当前主备节点角色，回滚备节点

#### 原主节点（现已备节点）升级失败
1. 报错并记录详细日志
2. VIP 在新主节点，服务继续可用
3. 手动回滚该节点
4. 新主节点继续提供服务

#### 健康检查失败
1. 报错并提供详细错误信息
2. 重试健康检查（可选）
3. 如果持续失败，报错并等待用户处理

---

## Open Questions

1. **Keepalived 配置文件路径和格式**
   - 问题：不清楚 Keepalived 配置文件的具体路径和配置格式
   - 影响：无法确定 priority 调整的具体实现方式
   - 解决：需要用户提供配置文件路径或示例配置

2. **升级包的具体格式和结构**
   - 问题：不清楚升级包的压缩格式（tar.gz、zip）和内部结构
   - 影响：无法设计解压和分发逻辑
   - 解决：需要用户提供升级包示例或格式规范

3. **分发升级包的接口定义**
   - 问题：不清楚"分发升级包的接口"的具体定义（HTTP 接口、参数格式）
   - 影响：无法设计升级触发逻辑
   - 解决：需要用户提供接口文档或示例调用

4. **schema 变更的具体流程**
   - 问题：不清楚表字段更新的具体 SQL 执行方式（脚本文件、接口调用）
   - 影响：无法设计数据库升级逻辑
   - 解决：需要用户提供 schema 变更脚本示例或执行方式

5. **健康检查接口的具体实现**
   - 问题：不清楚 `/health` 接口的具体实现位置（Java 服务、Python 服务、独立服务）
   - 影响：无法确定接口开发责任方
   - 解决：需要明确接口实现架构

6. **VIP 切换失败后的应急方案**
   - 问题：如果 priority 调整无法触发切换，是否有其他应急切换方式
   - 影响：升级失败时可能影响服务可用性
   - 解决：需要评估 dummy 接口方案或其他应急方案

7. **备份存储的可靠性和性能**
   - 问题：备份文件保存在本地还是远程，如何确保存储可靠性和访问性能
   - 影响：影响回滚速度和备份安全性
   - 解决：需要明确备份存储策略

8. **升级失败时的通知机制**
   - 问题：如何通知管理员升级失败（邮件、短信、日志告警？）
   - 影响：影响故障响应速度
   - 解决：需要明确通知渠道和格式
